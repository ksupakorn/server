--source include/galera_cluster.inc
--source include/have_innodb.inc
--source include/have_debug.inc
--source include/have_debug_sync.inc
--source include/force_restart.inc

#
# This test unit makes sure that it is not possible to have
# (1) User SQL-command KILL and
# (2) Brute Force (BF) lock conflict resolution kill
#
# executed concurrently so that server would hang. Instead
# idea is that only the first one setting thd->wsrep_aborter
# should be able to complete and other concurrent kill
# will bail out.
#

#
# Test case 1: Make sure user KILL SQL-command only kills victim thread
#
--echo #
--echo # Test case 1
--echo #
--connection node_2
CREATE TABLE t1(a int not null primary key auto_increment,b int) engine=InnoDB;
#
# connection node_2a runs a local transaction, that is victim of BF abort
# and victim of KILL command by connection node_2
#
--connect node_2a, 127.0.0.1, root, , test, $NODE_MYPORT_2
--connection node_2a
insert into t1 values (1,0);

# start a victim transaction that will conflict with later applier
begin;
update t1 set b=2 where a=1;
#
# Make sure update has started
#
--connection node_2
set session wsrep_sync_wait=0;
--let $wait_condition = SELECT COUNT(*) = 1 FROM INFORMATION_SCHEMA.PROCESSLIST WHERE USER = 'root' AND COMMAND = 'Sleep' LIMIT 1
--source include/wait_condition.inc
#
# Get thread ID for update transaction
#
--let $k_thread = `SELECT ID FROM INFORMATION_SCHEMA.PROCESSLIST WHERE USER = 'root' AND COMMAND = 'Sleep' LIMIT 1`
#
# pause KILL execution before awake
#
SET DEBUG_SYNC= 'wsrep_kill_one_thread_before_awake SIGNAL awake_reached WAIT_FOR continue_kill';
--disable_query_log
--send_eval KILL $k_thread
--enable_query_log
#
# connection node_2b is for controlling debug sync points
# wait until KILL execution has reached sync point
#
--connect node_2b, 127.0.0.1, root, , test, $NODE_MYPORT_2
--connection node_2b
SET DEBUG_SYNC='now WAIT_FOR awake_reached';
#
# replicate an update, which is conflicting with
# victim at node_2a. However, this BF can't do
# lock conflict resolution as we have already started
# same victim_thread killing on user KILL execution.
#
--connection node_1
select * from t1;
--send update t1 set b= 5 where a=1;

--connection node_2b
--echo # release KILL operator
SET GLOBAL debug_dbug = "";
SET DEBUG_SYNC = "now SIGNAL continue_kill";

--connection node_2
--reap
COMMIT;

--connection node_2a
--error 2013
COMMIT;

--connection node_1
--reap
SELECT * FROM t1;
DROP TABLE t1;

--connection node_2b
SET DEBUG_SYNC = "RESET";

--disconnect node_2a
--disconnect node_2b
#
# Test case 2: Execute user KILL SQL-query to gap in kill_one_thread
# where we do not have any mutexes and victim_thread->wsrep_aborter
# is not set. But even then BF kill should be only one killing victim.
#
--echo #
--echo # Test case 2
--echo #
--connection node_2
CREATE TABLE t1(a int not null primary key auto_increment,b int) engine=InnoDB;
#
# connection node_2a runs a local transaction, that is victim of BF abort
# and victim of KILL command by connection node_2
#
--connect node_2a, 127.0.0.1, root, , test, $NODE_MYPORT_2
--connection node_2a
insert into t1 values (1,0);

# start a victim transaction that will conflict with later applier
begin;
update t1 set b=2 where a=1;
#
# Make sure update has started
#
--connection node_2
set session wsrep_sync_wait=0;
--let $wait_condition = SELECT COUNT(*) = 1 FROM INFORMATION_SCHEMA.PROCESSLIST WHERE USER = 'root' AND COMMAND = 'Sleep' LIMIT 1
--source include/wait_condition.inc
#
# Get thread ID for update transaction
#
--let $k_thread = `SELECT ID FROM INFORMATION_SCHEMA.PROCESSLIST WHERE USER = 'root' AND COMMAND = 'Sleep' LIMIT 1`
#
# pause KILL execution before ha_kill_query
#
SET DEBUG_SYNC= 'wsrep_kill_one_thread_before_kill_query SIGNAL kill_query_reached WAIT_FOR continue_kill';
--disable_query_log
--send_eval KILL $k_thread
--enable_query_log
#
# connection node_2b is for controlling debug sync points
# wait until KILL execution has reached sync point
#
--connect node_2b, 127.0.0.1, root, , test, $NODE_MYPORT_2
--connection node_2b
SET DEBUG_SYNC='now WAIT_FOR kill_query_reached';
#
# replicate an update, which is conflicting with
# victim at node_2a. BF kill should handle it
#
--connection node_1
select * from t1;
--send update t1 set b= 5 where a=1;

--connection node_2b
--echo # release KILL operator
SET GLOBAL debug_dbug = "";
SET DEBUG_SYNC = "now SIGNAL continue_kill";

--connection node_2
--reap

--connection node_2a
--error 2013,1213
COMMIT;

--connection node_1
--reap
SELECT * FROM t1;
DROP TABLE t1;

--connection node_2b
SET DEBUG_SYNC = "RESET";

--disconnect node_2a
--disconnect node_2b
#
# Test case 3: Execute user KILL SQL-query to sync point just
# before thd->awake. Make sure that bf kill does not proceed
# to kill victim thread.
#
--echo #
--echo # Test case 3
--echo #
--connection node_2
CREATE TABLE t1(a int not null primary key auto_increment,b int) engine=InnoDB;
#
# connection node_2a runs a local transaction, that is victim of BF abort
# and victim of KILL command by connection node_2
#
--connect node_2a, 127.0.0.1, root, , test, $NODE_MYPORT_2
--connection node_2a
insert into t1 values (1,0);

# start a victim transaction that will conflict with later applier
begin;
update t1 set b=2 where a=1;
#
# Make sure update has started
#
--connection node_2
set session wsrep_sync_wait=0;
--let $wait_condition = SELECT COUNT(*) = 1 FROM INFORMATION_SCHEMA.PROCESSLIST WHERE USER = 'root' AND COMMAND = 'Sleep' LIMIT 1
--source include/wait_condition.inc
#
# Get thread ID for update transaction
#
--let $k_thread = `SELECT ID FROM INFORMATION_SCHEMA.PROCESSLIST WHERE USER = 'root' AND COMMAND = 'Sleep' LIMIT 1`
#
# pause KILL execution before awake
#
SET DEBUG_SYNC= 'wsrep_kill_one_thread_before_awake SIGNAL awake_reached WAIT_FOR continue_kill';
--disable_query_log
--send_eval KILL $k_thread
--enable_query_log
#
# connection node_2b is for controlling debug sync points
# wait until KILL has reached sync point
#
--connect node_2b, 127.0.0.1, root, , test, $NODE_MYPORT_2
--connection node_2b
SET DEBUG_SYNC='now WAIT_FOR awake_reached';
#
# replicate an update, which will run on applier as BF.
# However, as KILL has reserved kill rights, BF kill will
# not be executed.
#
--connection node_1
select * from t1;
update t1 set b= 5 where a=1;

--connection node_2b
--echo # release KILL operator
SET GLOBAL debug_dbug = "";
SET DEBUG_SYNC = "now SIGNAL continue_kill";

--connection node_2
--reap

--connection node_2a
--error 2013
COMMIT;

--connection node_1
SELECT * FROM t1;
DROP TABLE t1;

--connection node_2b
SET DEBUG_SYNC = "RESET";

--disconnect node_2a
--disconnect node_2b
#
# Test case 4: Execute user KILL SQL-query to gap in kill_one_thread
# where we do not have any mutexes and victim_thread->wsrep_aborter
# is not set. Execute BF kill until we have set victim_thread->aborter
# and make sure that user KILL can't kill victim thread.
#
--echo #
--echo # Test case 4
--echo #
--connection node_2
CREATE TABLE t1(a int not null primary key auto_increment,b int) engine=InnoDB;
#
# connection node_2a runs a local transaction, that is victim of BF abort
# and victim of KILL command by connection node_2
#
--connect node_2a, 127.0.0.1, root, , test, $NODE_MYPORT_2
--connection node_2a
insert into t1 values (1,0);

# start a victim transaction that will conflict with later applier
begin;
update t1 set b=2 where a=1;
#
# Make sure update has started
#
--connection node_2
set session wsrep_sync_wait=0;
--let $wait_condition = SELECT COUNT(*) = 1 FROM INFORMATION_SCHEMA.PROCESSLIST WHERE USER = 'root' AND COMMAND = 'Sleep' LIMIT 1
--source include/wait_condition.inc
#
# Get thread ID for update transaction
#
--let $k_thread = `SELECT ID FROM INFORMATION_SCHEMA.PROCESSLIST WHERE USER = 'root' AND COMMAND = 'Sleep' LIMIT 1`
#
# pause KILL execution before ha_kill_query
#
SET DEBUG_SYNC= 'wsrep_kill_one_thread_before_kill_query SIGNAL kill_query_reached WAIT_FOR continue_kill';
--disable_query_log
--send_eval KILL $k_thread
--enable_query_log
#
# connection node_2b is for controlling debug sync points
# wait until kill reached sync point
--connect node_2b, 127.0.0.1, root, , test, $NODE_MYPORT_2
--connection node_2b
SET DEBUG_SYNC='now WAIT_FOR kill_query_reached';
#
# Set a sync point for applier, to pause during BF aborting
# and before THD::awake would be called
#
SET GLOBAL debug_dbug = "d,sync.wsrep_innobase_kill_one_trx_before_awake";
#
# replicate an update, which will BF abort the victim node_2a
# however, while applier in node 2 is handling the abort,
# it will pause in sync point set by node_2b
#
--connection node_1
select * from t1;
update t1 set b= 5 where a=1;
#
# wait until the applying of above update has reached the sync point
# in node 2
#
--connection node_2b
SET SESSION DEBUG_SYNC = "now WAIT_FOR sync.wsrep_innobase_kill_one_trx_before_awake";

SET GLOBAL debug_dbug = "";
--echo # release bf kill
set DEBUG_SYNC = "now SIGNAL signal.wsrep_innobase_kill_one_trx_before_awake";

--connection node_2a
--error 1213
COMMIT;
SELECT * FROM t1;

--echo # release KILL operator
SET DEBUG_SYNC = "now SIGNAL continue_kill";

--connection node_2
--reap
COMMIT;
SELECT * FROM t1;

--connection node_1
COMMIT;
SELECT * from t1;
DROP TABLE t1;

--connection node_2b
SET DEBUG_SYNC = "RESET";

--disconnect node_2a
--disconnect node_2b
#
# Test case 5: Make sure that only bf lock conflict resolution
# kills victim thread.
#
--echo #
--echo # Test case 5
--echo #
--connection node_2
CREATE TABLE t1(a int not null primary key auto_increment,b int) engine=InnoDB;
#
# connection node_2a runs a local transaction, that is victim of BF abort
# and victim of KILL command by connection node_2
#
--connect node_2a, 127.0.0.1, root, , test, $NODE_MYPORT_2
--connection node_2a
insert into t1 values (1,0);

# start a victim transaction that will conflict with later applier
begin;
update t1 set b=2 where a=1;
#
# Make sure update has started
#
--connection node_2
set session wsrep_sync_wait=0;
--let $wait_condition = SELECT COUNT(*) = 1 FROM INFORMATION_SCHEMA.PROCESSLIST WHERE USER = 'root' AND COMMAND = 'Sleep' LIMIT 1
--source include/wait_condition.inc
#
# Get thread ID for update transaction
#
--let $k_thread = `SELECT ID FROM INFORMATION_SCHEMA.PROCESSLIST WHERE USER = 'root' AND COMMAND = 'Sleep' LIMIT 1`
#
# connection node_2b is for controlling debug sync points
# first set a sync point for applier, to pause during BF aborting
# and before THD::awake would be called
#
--connect node_2b, 127.0.0.1, root, , test, $NODE_MYPORT_2
--connection node_2b
SET GLOBAL debug_dbug = "d,sync.wsrep_innobase_kill_one_trx_before_LOCK_thd_data";
#
# replicate an update, which will BF abort the victim node_2a
# however, while applier in node 2 is handling the abort,
# it will pause in sync point set by node_2b
#
--connection node_1
select * from t1;
update t1 set b= 5 where a=1;
#
# wait until the applying of above update has reached the sync point
# in node 2
#
--connection node_2b
SET SESSION DEBUG_SYNC = "now WAIT_FOR sync.wsrep_innobase_kill_one_trx_before_LOCK_thd_data";
#
# pause KILL execution before awake
#
--connection node_2
SET DEBUG_SYNC= 'wsrep_kill_one_thread_started SIGNAL awake_reached WAIT_FOR continue_kill';
--disable_query_log
--send_eval KILL $k_thread
--enable_query_log

--connection node_2b
SET DEBUG_SYNC='now WAIT_FOR awake_reached';

SET GLOBAL debug_dbug = "";
--connection node_2b
--echo # release KILL operator
SET DEBUG_SYNC = "now SIGNAL continue_kill";
--echo # Release applier
SET DEBUG_SYNC = "now SIGNAL signal.wsrep_innobase_kill_one_trx_before_LOCK_thd_data";

--connection node_2a
--error ER_LOCK_DEADLOCK
COMMIT;

--connection node_2
--reap

--connection node_1
SELECT * FROM t1;
DROP TABLE t1;

--connection node_2b
SET DEBUG_SYNC = "RESET";

--disconnect node_2a
--disconnect node_2b
